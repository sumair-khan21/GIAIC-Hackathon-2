<!--
SYNC IMPACT REPORT
==================
Version Change: [INITIAL] → 1.0.0
Change Type: MAJOR (Initial Constitution)
Modified Principles: N/A (new creation)
Added Sections:
  - Core Principles (7 principles)
  - Phase I Technical Constraints
  - Development Workflow
  - Governance
Removed Sections: N/A
Templates Status:
  ✅ plan-template.md - Constitution Check section aligns with principles
  ✅ spec-template.md - Requirements and acceptance criteria align with SDD workflow
  ✅ tasks-template.md - Task structure supports spec-driven phases
Follow-up TODOs: None
-->

# The Evolution of Todo - Phase I Constitution

## Core Principles

### I. Spec-Driven Development (SDD) - NON-NEGOTIABLE

All development MUST follow the strict five-step workflow:

1. **Constitution** - Project governance and constraints are defined
2. **Specification** - Feature requirements and acceptance criteria are documented
3. **Execution Plan** - Architecture and implementation approach are designed
4. **Task Breakdown** - Actionable, testable tasks are created
5. **Claude Code Implementation** - Code is generated by Claude Code only

**Rationale**: Spec-Driven Development ensures all work is deliberate, documented, and traceable. No implementation occurs without explicit specification and planning. This prevents scope creep, maintains clarity, and creates a complete audit trail for hackathon evaluation.

**Enforcement**:
- No step may be skipped
- Each step MUST be completed and approved before proceeding to the next
- All decisions MUST be documented in the appropriate artifact
- Agents MUST block any attempt to bypass this workflow

### II. AI-Generated Code Only - NON-NEGOTIABLE

All production code MUST be generated exclusively by Claude Code.

**Allowed human activities**:
- Writing specifications and requirements
- Reviewing generated code outputs
- Refining prompts and clarifications
- Approving or rejecting generated code

**Prohibited human activities**:
- Writing any production code manually
- Editing generated code directly
- Implementing features through hand-written logic
- Creating code files without Claude Code

**Rationale**: This hackathon demonstrates mastery of AI-assisted development. Manual coding undermines the project's core premise and evaluation criteria. All code quality, architecture, and implementation decisions must flow through Claude Code's generation capabilities.

**Enforcement**:
- `todo-spec-manager` agent MUST verify all code is AI-generated
- Git commits MUST reference the specification or task that triggered generation
- Code reviews MUST validate against specifications, not subjective preferences

### III. Phase I Scope Boundaries - NON-NEGOTIABLE

Phase I is strictly limited to an in-memory, console-based Python todo application.

**Allowed features**:
- Add Task (with title and description)
- List Tasks (display all tasks)
- Update Task (modify title, description, or status)
- Delete Task (remove task by ID)
- Mark Task Complete/Incomplete (toggle status)

**Allowed technologies**:
- Python 3.13 or higher
- Python standard library only
- Console input/output (stdin/stdout)
- In-memory data structures (lists, dictionaries)

**Prohibited features and technologies**:
- Database systems (SQLite, PostgreSQL, MySQL, MongoDB, etc.)
- Web frameworks (Flask, Django, FastAPI, etc.)
- AI/ML integrations (OpenAI, Anthropic, local models, etc.)
- External APIs or network calls
- File persistence (JSON, CSV, pickle, etc.)
- GUI frameworks (Tkinter, PyQt, etc.)
- Additional features beyond the five allowed operations

**Rationale**: Phase I establishes the foundation. Scope discipline is critical for hackathon success. Future phases (II, III, IV) will add databases, web interfaces, and AI - but only after Phase I is complete and evaluated. Attempting Phase II features in Phase I results in disqualification.

**Enforcement**:
- Specifications MUST NOT include prohibited features
- `todo-spec-manager` agent MUST reject specs violating Phase I boundaries
- Code validation MUST scan for prohibited imports and patterns
- Any violation MUST trigger immediate rejection and reversion

### IV. Anti-Vibe Coding - NON-NEGOTIABLE

No code may be implemented based on intuition, assumptions, or implicit understanding.

**Requirements**:
- Every behavior MUST be explicitly defined in the specification
- Every edge case MUST be documented before implementation
- Every validation rule MUST be stated in acceptance criteria
- Every error message MUST be specified in the spec

**Prohibited practices**:
- "This feels like the right way to do it"
- "Users probably expect this behavior"
- "It's obvious what should happen here"
- "Let's add this just in case"

**Rationale**: Vibe coding leads to undocumented behavior, inconsistent implementations, and failed acceptance criteria. Specifications are the single source of truth. If it's not in the spec, it doesn't get implemented.

**Enforcement**:
- During implementation, agents MUST reference specific spec sections
- Code reviews MUST verify every behavior has a corresponding spec requirement
- Ambiguities MUST trigger clarification requests, not assumptions

### V. Mandatory Clarification Protocol - NON-NEGOTIABLE

When any requirement, constraint, or expectation is unclear, development MUST STOP.

**Clarification triggers**:
- Ambiguous acceptance criteria
- Conflicting requirements
- Missing edge case definitions
- Undefined error handling behavior
- Unclear data validation rules
- Uncertain user interaction flows

**Clarification process**:
1. STOP all implementation work immediately
2. Document the specific ambiguity or uncertainty
3. Formulate 2-3 targeted clarifying questions
4. Present questions to the user (human-as-tool strategy)
5. WAIT for explicit answers
6. Update specification with clarified requirements
7. Resume implementation only after clarification is documented

**Prohibited responses to ambiguity**:
- Making assumptions and proceeding
- Implementing "both ways" and letting user choose later
- Deferring decisions to later phases
- Copying behavior from similar systems

**Rationale**: Ambiguity is the enemy of spec-driven development. Assumptions create technical debt, failed acceptance criteria, and rework. Clarification up-front saves time and ensures the implementation matches user intent.

**Enforcement**:
- All agents MUST invoke the human-as-tool protocol when ambiguity is detected
- Specifications MUST mark unclear sections with `[NEEDS CLARIFICATION: reason]`
- Implementation MUST NOT proceed past marked sections until resolved

### VI. Code Quality: Beginner-Friendly Clarity

All generated code MUST prioritize readability and educational value.

**Code standards**:
- Clear, descriptive variable and function names
- Simple, straightforward logic (avoid clever/terse solutions)
- Explicit over implicit (no magic behavior)
- Comments only where logic is non-obvious (prefer self-documenting code)
- Consistent formatting and style (PEP 8 for Python)
- Minimal abstractions (no premature optimization)

**Design principles**:
- Functions with single, clear responsibilities
- Limited function length (prefer 10-20 lines)
- Obvious control flow (minimize nested conditionals)
- Explicit error messages with actionable guidance

**Rationale**: This hackathon is an educational demonstration. Code must be approachable for developers learning spec-driven development and AI-assisted coding. Production-ready doesn't mean complex - it means clear, maintainable, and correct.

**Enforcement**:
- `python-cli-specialist` agent validates code clarity during reviews
- Generated code MUST pass readability standards before acceptance
- Complexity MUST be justified (and is generally a sign of over-engineering for Phase I)

### VII. Agent Governance and Authority

The `todo-spec-manager` agent has final authority over all Phase I development decisions.

**Agent hierarchy**:
1. **todo-spec-manager** (Governor)
   - Enforces constitution compliance
   - Validates specification completeness
   - Approves/rejects execution plans
   - Verifies task breakdown alignment
   - Has veto power over all decisions

2. **todo-domain-expert** (Advisor)
   - Provides domain logic guidance
   - Identifies edge cases and acceptance criteria gaps
   - Reviews specifications for completeness
   - Cannot override governance decisions

3. **python-cli-specialist** (Implementer)
   - Generates clean, beginner-friendly Python code
   - Implements CLI interaction patterns
   - Validates code quality and readability
   - Executes only approved tasks

4. **strict-evaluator** (Quality Gate)
   - Reviews specs, plans, and implementations from judge's perspective
   - Predicts hackathon scoring
   - Identifies demo-readiness issues
   - Provides critical feedback before finalization

**Conflict resolution**:
- Domain expert and specialist agents may advise
- `todo-spec-manager` makes final decisions
- All conflicts default to constitution compliance
- When constitution is unclear, STOP and invoke human clarification

**Rationale**: Clear authority prevents decision paralysis and ensures consistent enforcement of principles. The governance agent is specifically designed to maintain Phase I boundaries and SDD workflow integrity.

**Enforcement**:
- All agents MUST defer to `todo-spec-manager` on governance questions
- `todo-spec-manager` MUST block any constitutional violations
- Appeals to human only when constitution itself is ambiguous

## Phase I Technical Constraints

### Programming Language

- **Python Version**: 3.13 or higher (REQUIRED)
- **Dependencies**: Python standard library ONLY
- **Prohibited**: Third-party packages, pip installations, external modules

### Data Storage

- **Storage Type**: In-memory only (lists, dictionaries, sets)
- **Persistence**: None (data is lost when program exits)
- **Prohibited**: Files, databases, caching systems, serialization

### User Interface

- **Interface Type**: Console-based command-line interface (CLI)
- **Input Methods**: Text prompts, menu selections, command arguments
- **Output Methods**: Formatted text to stdout, errors to stderr
- **Prohibited**: Web UIs, GUIs, REST APIs, GraphQL endpoints

### Project Structure

```
todo_cli/
├── src/
│   ├── __init__.py
│   ├── models.py          # Task data structures
│   ├── operations.py      # CRUD operations
│   ├── cli.py             # User interface logic
│   └── main.py            # Entry point
├── tests/                  # Optional (if testing is specified)
│   └── test_operations.py
├── specs/
│   └── [feature]/
│       ├── spec.md
│       ├── plan.md
│       └── tasks.md
├── .specify/
│   ├── memory/
│   │   └── constitution.md  # This file
│   └── templates/
├── README.md
└── requirements.txt        # Empty or python>=3.13 only
```

### Code Organization

- **Separation of Concerns**: Models, operations, and UI in separate modules
- **Single Responsibility**: Each function performs one clear operation
- **No Global State**: Use function parameters and return values (in-memory store may be module-level)
- **Error Handling**: Explicit error messages, no silent failures

### Performance Expectations

- **Response Time**: Instant for all operations (in-memory access)
- **Data Scale**: Support up to 1000 tasks without degradation
- **Memory**: Reasonable usage (no memory leaks, efficient structures)

## Development Workflow

### Step 1: Constitution (Complete)

This document defines all governance, principles, and constraints for Phase I.

**Completion Criteria**:
- All principles clearly stated
- Phase I boundaries explicitly defined
- Agent authority established
- Technical constraints documented

### Step 2: Specification

For each feature, create `specs/[feature]/spec.md` using the specification template.

**Required sections**:
- User scenarios with Given/When/Then acceptance criteria
- Functional requirements (numbered FR-001, FR-002, etc.)
- Edge cases and error conditions
- Success criteria (measurable outcomes)
- Key entities and data structures (conceptual, not implementation)

**Completion Criteria**:
- All acceptance criteria are testable
- All edge cases are documented
- No ambiguities or `[NEEDS CLARIFICATION]` markers remain
- `todo-domain-expert` has reviewed and approved
- `todo-spec-manager` has validated completeness

**Governance Gate**:
- Specifications violating Phase I scope MUST be rejected
- Specifications with manual coding steps MUST be rejected
- Specifications MUST be approved before planning begins

### Step 3: Execution Plan

Create `specs/[feature]/plan.md` using the planning template.

**Required sections**:
- Technical context (Python 3.13, in-memory, console)
- Constitution check (validate against all seven principles)
- Project structure (verify alignment with Phase I structure)
- Implementation approach (architectural decisions)
- Complexity justification (if any constitutional violations need approval)

**Completion Criteria**:
- Constitution check passes (or violations are justified and approved)
- Project structure matches Phase I constraints
- Architecture is simple and appropriate for console app
- No prohibited technologies appear in plan
- `python-cli-specialist` has reviewed implementation approach
- `strict-evaluator` has assessed demo-readiness

**Governance Gate**:
- Plans with database designs MUST be rejected (Phase II)
- Plans with web frameworks MUST be rejected (Phase II)
- Plans with AI integrations MUST be rejected (Phase IV)
- All architecture decisions MUST reference constitution principles

### Step 4: Task Breakdown

Create `specs/[feature]/tasks.md` using the tasks template.

**Required sections**:
- Tasks organized by user story (independent, testable increments)
- Task IDs, descriptions, and file paths
- Dependencies and parallel opportunities
- Checkpoints for independent validation

**Task format**: `[ID] [P?] [Story] Description with exact file path`

**Completion Criteria**:
- Every acceptance criterion has corresponding implementation tasks
- Tasks are granular (each modifies 1-2 files)
- Dependencies are explicit and minimal
- Parallel tasks are marked with [P]
- `todo-spec-manager` has verified alignment with spec and plan

**Governance Gate**:
- Tasks MUST reference approved specification and plan
- Tasks creating prohibited files/features MUST be rejected
- Task descriptions MUST be concrete (no vague "implement feature" tasks)

### Step 5: Claude Code Implementation

Execute tasks using Claude Code with `/sp.implement` or manual task execution.

**Implementation requirements**:
- Generate code ONLY for approved tasks
- Reference specific spec sections and acceptance criteria
- Follow Python code quality standards (Principle VI)
- Include error messages exactly as specified in spec
- Test against acceptance criteria after each task

**Validation after implementation**:
- Run code and verify all acceptance criteria pass
- Check Phase I compliance (no prohibited imports/features)
- Validate code quality and readability
- Confirm no manual code edits were made

**Governance Gate**:
- Code with prohibited imports MUST be rejected
- Code with undefined behavior (not in spec) MUST be rejected
- Code failing acceptance criteria MUST be revised
- Manual edits MUST be reverted and regenerated via Claude Code

## Governance

### Constitutional Authority

This Constitution supersedes all other development practices, preferences, and conventions. When any conflict arises between this Constitution and other guidance (templates, examples, agent suggestions), the Constitution prevails.

### Amendment Process

The Constitution may be amended only:

1. With explicit human approval
2. After documenting the reason for amendment
3. With a version increment following semantic versioning:
   - **MAJOR**: Backward-incompatible changes (removing/redefining principles)
   - **MINOR**: New principles or expanded guidance
   - **PATCH**: Clarifications, wording improvements, typo fixes
4. With a Sync Impact Report documenting affected templates and artifacts

### Compliance Review

All development artifacts MUST be reviewed for constitutional compliance:

- **Specifications**: Reviewed by `todo-spec-manager` before planning
- **Plans**: Reviewed for Phase I boundaries and technical constraints
- **Tasks**: Reviewed for alignment with approved specs and plans
- **Code**: Reviewed for prohibited features, manual edits, and quality standards

### Violation Handling

When a constitutional violation is detected:

1. **STOP** all related work immediately
2. **DOCUMENT** the specific principle violated
3. **REVERT** to the last compliant state
4. **CLARIFY** the requirement or constraint
5. **REVISE** the artifact to comply
6. **RESUME** only after compliance is verified

### Complexity Justification

Any deviation from constitutional principles MUST be justified in writing before proceeding. Justifications must include:

- Which principle is being violated
- Why the violation is necessary for Phase I
- What simpler alternatives were considered and rejected
- Why those alternatives are insufficient

Most complexity is unjustified for Phase I. In-memory console apps should be simple.

### Documentation Requirements

All development artifacts MUST be:

- Written in clear, professional Markdown
- Stored in the appropriate `specs/[feature]/` directory
- Version-controlled with Git
- Referenced in code comments and commit messages

### Hackathon Evaluation Alignment

This Constitution is designed for hackathon evaluation. Judges will assess:

- **Spec-Driven Development**: Complete, traceable workflow from spec to code
- **AI Code Generation**: All code generated by Claude Code, no manual edits
- **Phase I Scope Discipline**: Strict adherence to in-memory console constraints
- **Clarity and Documentation**: Specifications, plans, and code are clear and complete
- **Demo-Readiness**: Working application that matches all specifications

**Version**: 1.0.0 | **Ratified**: 2025-12-31 | **Last Amended**: 2025-12-31
